/**
 * Timetable Generator
 * Generates Airflow Timetable classes from CalendarEntry configurations
 */

import type { CalendarEntry } from "@/lib/storage/config-storage";

/**
 * Pattern to weekday set mapping
 */
const WEEKDAY_MAP: Record<string, number> = {
  MON: 0,
  TUE: 1,
  WED: 2,
  THU: 3,
  FRI: 4,
  SAT: 5,
  SUN: 6,
};

/**
 * Parse a weekday pattern string to a set of weekday numbers
 * Examples: "MON-FRI" -> {0,1,2,3,4}, "SAT,SUN" -> {5,6}
 */
function parseWeekdayPattern(pattern: string): Set<number> {
  const weekdays = new Set<number>();

  // Handle range pattern like "MON-FRI"
  if (pattern.includes("-")) {
    const [start, end] = pattern.split("-").map((d) => d.trim().toUpperCase());
    const startDay = WEEKDAY_MAP[start];
    const endDay = WEEKDAY_MAP[end];
    if (startDay !== undefined && endDay !== undefined) {
      for (let i = startDay; i <= endDay; i++) {
        weekdays.add(i);
      }
    }
  } else {
    // Handle comma-separated like "MON,WED,FRI"
    const days = pattern.split(",").map((d) => d.trim().toUpperCase());
    for (const day of days) {
      if (WEEKDAY_MAP[day] !== undefined) {
        weekdays.add(WEEKDAY_MAP[day]);
      }
    }
  }

  return weekdays;
}

/**
 * Merge multiple calendars into unified exclusion/inclusion rules
 */
interface MergedCalendarConfig {
  excludedDates: Set<string>;
  weekdayPattern: Set<number>;
  includedDates: Set<string>;
  timezone: string;
  calendarNames: string[];
}

function mergeCalendars(calendars: CalendarEntry[]): MergedCalendarConfig {
  const result: MergedCalendarConfig = {
    excludedDates: new Set(),
    weekdayPattern: new Set([0, 1, 2, 3, 4, 5, 6]), // Default: all days
    includedDates: new Set(),
    timezone: "UTC",
    calendarNames: [],
  };

  let hasWeekdayRestriction = false;

  for (const cal of calendars) {
    result.calendarNames.push(cal.name);

    // Set timezone from first calendar that has it
    if (cal.timezone && result.timezone === "UTC") {
      result.timezone = cal.timezone;
    }

    // Process based on calendar type
    switch (cal.type) {
      case "holidays":
        // Add excluded dates
        if (cal.excludedDates) {
          for (const date of cal.excludedDates) {
            result.excludedDates.add(date);
          }
        }
        break;

      case "business_days":
      case "weekly_pattern":
        // Parse weekday pattern
        if (cal.pattern) {
          const pattern = parseWeekdayPattern(cal.pattern);
          if (!hasWeekdayRestriction) {
            // First weekday pattern - use it
            result.weekdayPattern = pattern;
            hasWeekdayRestriction = true;
          } else {
            // Intersect with existing pattern
            const intersection = new Set<number>();
            for (const day of pattern) {
              if (result.weekdayPattern.has(day)) {
                intersection.add(day);
              }
            }
            result.weekdayPattern = intersection;
          }
        }
        // Also add excluded dates if any
        if (cal.excludedDates) {
          for (const date of cal.excludedDates) {
            result.excludedDates.add(date);
          }
        }
        break;

      case "custom":
        // Add included dates (run only on these dates)
        if (cal.includedDates) {
          for (const date of cal.includedDates) {
            result.includedDates.add(date);
          }
        }
        break;
    }
  }

  return result;
}

/**
 * Generate Python Timetable class code from CalendarEntry[]
 */
export function generateEmbeddedTimetable(
  calendars: CalendarEntry[],
  className: string = "OFlairCalendarTimetable"
): string {
  const config = mergeCalendars(calendars);
  const lines: string[] = [];

  // Class definition
  lines.push(`class ${className}(Timetable):`);
  lines.push(`    """`);
  lines.push(`    Calendar-aware timetable generated by OFlair.`);
  lines.push(`    Configured calendars: ${config.calendarNames.join(", ")}`);
  lines.push(`    """`);
  lines.push(``);

  // Excluded dates as class attribute
  if (config.excludedDates.size > 0) {
    const sortedDates = Array.from(config.excludedDates).sort();
    lines.push(`    # Holiday dates to exclude`);
    lines.push(`    EXCLUDED_DATES = {`);
    for (const date of sortedDates) {
      lines.push(`        '${date}',`);
    }
    lines.push(`    }`);
  } else {
    lines.push(`    EXCLUDED_DATES = set()  # No excluded dates`);
  }
  lines.push(``);

  // Weekday pattern as class attribute
  const weekdayStr = Array.from(config.weekdayPattern).sort().join(", ");
  const weekdayNames = Array.from(config.weekdayPattern)
    .sort()
    .map((d) => Object.entries(WEEKDAY_MAP).find(([, v]) => v === d)?.[0])
    .filter(Boolean)
    .join(", ");
  lines.push(`    # Valid weekdays (0=Mon, 6=Sun) - ${weekdayNames}`);
  lines.push(`    WEEKDAY_PATTERN = {${weekdayStr}}`);
  lines.push(``);

  // Included dates (for custom calendars)
  if (config.includedDates.size > 0) {
    const sortedDates = Array.from(config.includedDates).sort();
    lines.push(`    # Custom dates to include (run only on these dates)`);
    lines.push(`    INCLUDED_DATES = {`);
    for (const date of sortedDates) {
      lines.push(`        '${date}',`);
    }
    lines.push(`    }`);
    lines.push(``);
  }

  // Constructor
  lines.push(`    def __init__(self, timezone: str = "${config.timezone}"):`);
  lines.push(`        self.timezone = Timezone(timezone)`);
  lines.push(``);

  // is_valid_day method
  lines.push(`    def is_valid_day(self, dt: DateTime) -> bool:`);
  lines.push(`        """Check if date is a valid execution day"""`);

  if (config.includedDates.size > 0) {
    // Custom mode: only run on included dates
    lines.push(`        # Custom calendar: run only on included dates`);
    lines.push(`        return dt.strftime('%Y-%m-%d') in self.INCLUDED_DATES`);
  } else {
    lines.push(`        # Check weekday pattern`);
    lines.push(`        if dt.weekday() not in self.WEEKDAY_PATTERN:`);
    lines.push(`            return False`);
    lines.push(`        # Check excluded dates (holidays)`);
    lines.push(`        if dt.strftime('%Y-%m-%d') in self.EXCLUDED_DATES:`);
    lines.push(`            return False`);
    lines.push(`        return True`);
  }
  lines.push(``);

  // infer_manual_data_interval method
  lines.push(`    def infer_manual_data_interval(self, run_after: DateTime) -> DataInterval:`);
  lines.push(`        start = run_after.in_timezone(self.timezone).start_of('day')`);
  lines.push(`        return DataInterval(start=start, end=start + timedelta(days=1))`);
  lines.push(``);

  // next_dagrun_info method
  lines.push(`    def next_dagrun_info(`);
  lines.push(`        self,`);
  lines.push(`        *,`);
  lines.push(`        last_automated_data_interval: Optional[DataInterval],`);
  lines.push(`        restriction: TimeRestriction,`);
  lines.push(`    ) -> Optional[DagRunInfo]:`);
  lines.push(`        if last_automated_data_interval is None:`);
  lines.push(`            start = restriction.earliest`);
  lines.push(`            if start is None:`);
  lines.push(`                return None`);
  lines.push(`            start = start.in_timezone(self.timezone).start_of('day')`);
  lines.push(`        else:`);
  lines.push(`            start = last_automated_data_interval.end`);
  lines.push(``);
  lines.push(`        # Find next valid day (max 365 iterations to prevent infinite loop)`);
  lines.push(`        for _ in range(365):`);
  lines.push(`            if self.is_valid_day(start):`);
  lines.push(`                break`);
  lines.push(`            start = start + timedelta(days=1)`);
  lines.push(`        else:`);
  lines.push(`            return None  # No valid day found in next year`);
  lines.push(``);
  lines.push(`        end = start + timedelta(days=1)`);
  lines.push(``);
  lines.push(`        if restriction.latest is not None and start > restriction.latest:`);
  lines.push(`            return None`);
  lines.push(``);
  lines.push(`        return DagRunInfo(`);
  lines.push(`            run_after=start,`);
  lines.push(`            data_interval=DataInterval(start=start, end=end),`);
  lines.push(`        )`);

  return lines.join("\n");
}

/**
 * Generate required imports for Timetable
 */
export function generateTimetableImports(): string[] {
  return [
    "from typing import Optional",
    "from pendulum import DateTime, Timezone",
    "from airflow.timetables.base import DagRunInfo, DataInterval, TimeRestriction, Timetable",
  ];
}

/**
 * Get a description of the merged calendar config for comments
 */
export function getCalendarDescription(calendars: CalendarEntry[]): string[] {
  const config = mergeCalendars(calendars);
  const lines: string[] = [];

  lines.push(`Calendars: ${config.calendarNames.join(", ")}`);

  // Weekday pattern
  const weekdayNames = Array.from(config.weekdayPattern)
    .sort()
    .map((d) => Object.entries(WEEKDAY_MAP).find(([, v]) => v === d)?.[0])
    .filter(Boolean);
  if (weekdayNames.length < 7) {
    lines.push(`Run on: ${weekdayNames.join(", ")}`);
  } else {
    lines.push(`Run on: All days`);
  }

  // Excluded dates
  if (config.excludedDates.size > 0) {
    lines.push(`Excluded dates: ${config.excludedDates.size} holidays configured`);
  }

  // Timezone
  lines.push(`Timezone: ${config.timezone}`);

  return lines;
}
